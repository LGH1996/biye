C51 COMPILER V9.59.0.0   PROGRAMER                                                         05/20/2020 16:51:00 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE PROGRAMER
OBJECT MODULE PLACED IN .\Objects\programer.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE programer.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Li
                    -stings\programer.lst) TABS(2) OBJECT(.\Objects\programer.obj)

line level    source

   1          #include <reg52.h>
   2          #include <intrins.h>
   3          #include <string.h>
   4          
   5          #define ID "#0000000001"
   6          
   7          #define IAP_ADDR 0x4000 //ÄÚ²¿REPPROM´æ´¢ÓïÒôÄ£¿éÒôÁ¿ÖµµÄµØÖ·
   8          #define uchar unsigned char
   9          #define uint unsigned int
  10          
  11          sfr WDT_CONTR = 0xE1; //¶¨Òå¿´ÃÅ¹·¿ØÖÆ¼Ä´æÆ÷
  12          sfr IAP_DATA = 0xE2;  //¶¨Òå²Ù×÷EPPROMÏà¹ØµÄÌØÊâ¹¦ÄÜ¼Ä´æÆ÷
  13          sfr IAP_ADDRH = 0xE3;
  14          sfr IAP_ADDRL = 0xE4;
  15          sfr IAP_CMD = 0xE5;
  16          sfr IAP_TRIG = 0xE6;
  17          sfr IAP_CONTR = 0xE7;
  18          sbit Echo = P1 ^ 1; //¶¨Òå¸÷ÀàÒý½Å
  19          sbit Trig = P1 ^ 2;
  20          sbit P2_0 = P2 ^ 0;
  21          sbit P2_1 = P2 ^ 1;
  22          bit lightStatus = 0; //¶¨Òå¸÷Àà±êÖ¾Î»ºÍ¸¨Öú±äÁ¿
  23          bit distanceNew = 0;
  24          uchar distanceNum = 0;
  25          uchar lightNum = 0;
  26          uchar lightStatusNum = 0;
  27          uchar distanceNewNum = 0;
  28          uchar distanceLastRange = 0x00;
  29          uint distanceLast = 0;
  30          uchar mediaCommand[] = {0x7E, 0xFF, 0x06, 0x00, 0x00, 0x00, 0x00, 0xEF}; //ÓïÒô²¥·ÅÄ£¿éµÄÖ¸Áî
  31          uchar volume = 0x0f;//ÓïÒôÄ£¿éµÄµ±Ç°ÉùÒô´óÐ¡
  32          uchar *gsmCmd[10] = {"AT+CIPSHUT\n", "AT+CGATT?\n", "AT+CSTT=\"CMNET\"\n",
  33                               "AT+CIICR\n", "AT+CIFSR\n", "AT+CIPSTART=\"TCP\",\"120.78.203.170\",\"12777\"\n",
  34                               "AT+CIPSEND\n", "gps", "\x1A", "AT+CIPCLOSE\n"}; //Ñ­»··¢ËÍµÄATÖ¸Áî
  35          uchar gsmNum = 0, gsmIndex = 0; //¿ØÖÆATÖ¸ÁîµÄ·¢ËÍË³Ðò
  36          uint receiveCount = 0;
  37          uchar receive[100], gpsSave[150]; //½ÓÊÕºÍ±£´æGPS¶¨Î»Êý¾Ý
  38          
  39          void delay(uint i) //ÑÓÊ±º¯Êý
  40          {
  41   1          uint n;
  42   1          for (n = 0; n < i; n++)
  43   1          {
  44   2              _nop_();
  45   2          }
  46   1      }
  47          
  48          void sendData(uchar str[], uchar lenth) //Ïò´®ÐÐ¿Ú·¢ËÍÊý¾Ý
  49          {
  50   1          uint n;
  51   1          for (n = 0; n < lenth; n++)
  52   1          {
  53   2              SBUF = str[n];
  54   2              while (TI == 0)
C51 COMPILER V9.59.0.0   PROGRAMER                                                         05/20/2020 16:51:00 PAGE 2   

  55   2                  ;
  56   2              TI = 0;
  57   2          }
  58   1      }
  59          
  60          void sendAt() //·¢ËÍATÖ¸Áî
  61          {
  62   1          sendData(gsmCmd[gsmIndex], strlen(gsmCmd[gsmIndex]));
  63   1          gsmNum = 0;
  64   1          gsmIndex++;
  65   1          gsmIndex %= 10;
  66   1          delay(1000);
  67   1      }
  68          
  69          void IapIdle() //½øÈë´ý»úÄ£Ê½£¬ÎÞISP/IAP²Ù×÷
  70          {
  71   1          IAP_CONTR = 0;
  72   1          IAP_CMD = 0;
  73   1          IAP_TRIG = 0;
  74   1          IAP_ADDRH = 0x80;
  75   1          IAP_ADDRL = 0;
  76   1      }
  77          
  78          uchar IapReadByte(uint addr) //¶ÔÄÚ²¿RPPROM½øÐÐ¶ÁÈ¡Êý¾Ý²Ù×÷
  79          {
  80   1          uchar dat;
  81   1          IAP_CONTR = 0x81;
  82   1          IAP_CMD = 0x01;
  83   1          IAP_ADDRL = addr;
  84   1          IAP_ADDRH = addr >> 8;
  85   1          IAP_TRIG = 0x46;
  86   1          IAP_TRIG = 0xb9;
  87   1          _nop_();
  88   1          dat = IAP_DATA;
  89   1          IapIdle();
  90   1          return dat;
  91   1      }
  92          
  93          void IapProgramByte(uint addr, uchar dat) //¶ÔÄÚ²¿REPPROM½øÐÐÐ´ÈëÊý¾Ý²Ù×÷
  94          {
  95   1          IAP_CONTR = 0x81;
  96   1          IAP_CMD = 0x02;
  97   1          IAP_ADDRL = addr;
  98   1          IAP_ADDRH = addr >> 8;
  99   1          IAP_DATA = dat;
 100   1          IAP_TRIG = 0x46;
 101   1          IAP_TRIG = 0xb9;
 102   1          _nop_();
 103   1          IapIdle();
 104   1      }
 105          
 106          void IapEraseSector(uint addr) //²Á³ýÄÚ²¿EPPROMµÄÖ¸¶¨ÉÈÇø
 107          {
 108   1          IAP_CONTR = 0x81;
 109   1          IAP_CMD = 0x03;
 110   1          IAP_ADDRL = addr;
 111   1          IAP_ADDRH = addr >> 8;
 112   1          IAP_TRIG = 0x46;
 113   1          IAP_TRIG = 0xb9;
 114   1          _nop_();
 115   1          IapIdle();
 116   1      }
C51 COMPILER V9.59.0.0   PROGRAMER                                                         05/20/2020 16:51:00 PAGE 3   

 117          
 118          void Time0() interrupt 1 using 0 //¶¨Ê±Æ÷T0ÖÐ¶Ïº¯Êý
 119          {
 120   1      
 121   1          if (++lightNum >= 5) //¼ì²éÍâ²¿¹âÏßÇ¿¶ÈµÄ±ä»¯
 122   1          {
 123   2              if (P2_0 != lightStatus)
 124   2              {
 125   3                  lightStatusNum++;
 126   3              }
 127   2              else
 128   2              {
 129   3                  lightStatusNum = 0;
 130   3              }
 131   2              if (lightStatus)
 132   2              {
 133   3                  P2_1 = !P2_1; //Ö¸Ê¾µÆÉÁË¸
 134   3              }
 135   2              lightNum = 0;
 136   2          }
 137   1      
 138   1          gsmNum++;
 139   1          distanceNum++;
 140   1          TH0 = 0x4C; //ÖØÐÂ×°ÔØ³õÖµ
 141   1          TL0 = 0x00;
 142   1      }
 143          
 144          void Time2() interrupt 5 using 1 //¶¨Ê±Æ÷T2µÄÖÐ¶Ïº¯Êý
 145          {
 146   1      
 147   1          if (EXF2) //Ê¹ÓÃ¶¨Ê±Æ÷T2µÄ²¶»ñÄ£Ê½
 148   1          {
 149   2              double rcap = (RCAP2H << 8 | RCAP2L); //»ñÈ¡·¢ÉúÖÐ¶ÏÊ±µÄTH2ºÍTL2µÄÖµ
 150   2              uint distance = (rcap * (12 / 11.0592) * 0.034) / 2; //¼ÆËã³öÓëÕÏ°­ÎïµÄ¾àÀë
 151   2              EXF2 = 0;
 152   2              if (distance < (distanceLast - 50) || distance > (distanceLast + 50)) //ÅÐ¶ÏÓëÕÏ°­µÄ¾àÀëÊÇ·ñ·¢ÉúÁË
             -½Ï´óµÄ±ä»¯
 153   2              {
 154   3                  distanceLast = distance;
 155   3                  distanceNewNum = 0;
 156   3                  distanceNew = 1;
 157   3              }
 158   2              else
 159   2              {
 160   3                  distanceNewNum++;
 161   3              }
 162   2          }
 163   1      }
 164          
 165          void serial_4() interrupt 4 using 3 //UARTÖÐ¶Ï£¬Ö÷ÒªÓÃÀ´½ÓÊÕGPSÄ£¿éµÄ¶¨Î»Êý¾Ý
 166          {
 167   1          if (RI)
 168   1          {
 169   2              uchar temp = SBUF;
 170   2              RI = 0;
 171   2              receive[receiveCount++] = temp;
 172   2              if (temp == '\n')
 173   2              {
 174   3                  receive[receiveCount] = 0;
 175   3                  if (receive[0] == '$' && receive[3] == 'G' && receive[4] == 'G' && receive[5] == 'A' && receiv
             -eCount >= 60 && receiveCount < 100)
 176   3                  {
C51 COMPILER V9.59.0.0   PROGRAMER                                                         05/20/2020 16:51:00 PAGE 4   

 177   4                      strcpy(gpsSave, receive);
 178   4                      strcat(gpsSave,ID);
 179   4                  }
 180   3                  receiveCount = 0;
 181   3                  receive[0] = 0;
 182   3              }
 183   2          }
 184   1      }
 185          
 186          void external_0() interrupt 0 using 2 //Íâ²¿ÖÐ¶ÏINT0µÄÖÐ¶Ïº¯Êý£¬ÓïÒôÄ£¿éÒôÁ¿¼Ó1
 187          {
 188   1          if (volume < 30)
 189   1          {
 190   2              mediaCommand[3] = 0x06;
 191   2              mediaCommand[6] = ++volume;
 192   2              sendData(mediaCommand, 8);
 193   2              IapEraseSector(IAP_ADDR);
 194   2              IapProgramByte(IAP_ADDR, volume);
 195   2          }
 196   1      }
 197          
 198          void external_1() interrupt 2 using 2 //Íâ²¿ÖÐ¶ÏINT1µÄÖÐ¶Ïº¯Êý£¬ÓïÒôÄ£¿éÒôÁ¿¼õ1
 199          {
 200   1          if (volume > 5)
 201   1          {
 202   2              mediaCommand[3] = 0x06;
 203   2              mediaCommand[6] = --volume;
 204   2              sendData(mediaCommand, 8);
 205   2              IapEraseSector(IAP_ADDR);
 206   2              IapProgramByte(IAP_ADDR, volume);
 207   2          }
 208   1      }
 209          
 210          void main()
 211          {
 212   1      
 213   1          EA = 1; //¿ª×ÜÖÐ¶Ï
 214   1      
 215   1          ET0 = 1; //¿ªT0ÖÐ¶Ï
 216   1          TR0 = 1;
 217   1          TMOD |= 0x01;
 218   1          TH0 = 0x4C;
 219   1          TL0 = 0x00;
 220   1      
 221   1          TR1 = 1; //ÉèÖÃ¶¨Ê±Æ÷T1Îª²¨ÌØÂÊ·¢ÉúÆ÷
 222   1          TMOD |= 0x20;
 223   1          TL1 = 0xFD;
 224   1          TH1 = 0xFD;
 225   1      
 226   1          ET2 = 1; //¿ª¶¨Ê±Æ÷/¼ÆÊýÆ÷T2µÄ²¶»ñÄ£Ê½
 227   1          TR2 = 1;
 228   1          EXEN2 = 1;
 229   1          CP_RL2 = 1;
 230   1      
 231   1          ES = 1; //¿ªUARTÖÐ¶Ï£¬ÉèÖÃ´®ÐÐ¿ÚÍ¨Ñ¶µÄ¹¤×÷Ä£Ê½
 232   1          SM0 = 0;
 233   1          SM1 = 1;
 234   1          REN = 1;
 235   1      
 236   1          EX0 = 1; //¿ªÍâ²¿ÖÐ¶ÏINT0ºÍINT1
 237   1          EX1 = 1;
 238   1          IT0 = 1;
C51 COMPILER V9.59.0.0   PROGRAMER                                                         05/20/2020 16:51:00 PAGE 5   

 239   1          IT1 = 1;
 240   1      
 241   1          WDT_CONTR = 0x37; //¿ª¿´ÃÅ¹·£¬ÔÚÊÜµ½¸ÉÈÅÊ¹³ÌÐòÅÜ·ÉÊ±×Ô¶¯¸´Î»
 242   1      
 243   1          memset(receive, 0, 100);
 244   1          memset(gpsSave, 0, 100);
 245   1          gsmCmd[7] = gpsSave;
 246   1      
 247   1          delay(20000); //µÈ´ýÓïÒôÄ£¿éÆô¶¯Íê±Ïºó
 248   1          volume = IapReadByte(IAP_ADDR);
 249   1          mediaCommand[3] = 0x06;
 250   1          mediaCommand[6] = volume;
 251   1          sendData(mediaCommand, 8); //³õÊ¼»¯ÓïÒôÄ£¿éµÄÒôÁ¿´óÐ¡
 252   1      
 253   1          while (1)
 254   1          {
 255   2      
 256   2              if (distanceNum >= 10) //ÔÚ¼ä¸ôÒ»¶¨µÄÊ±¼äºóÏò²â¾àÄ£¿é·¢ËÍ¸ßµçÆ½Âö³å
 257   2              {
 258   3                  Trig = 0;
 259   3                  delay(10);
 260   3                  Trig = 1;
 261   3                  while (!Echo)
 262   3                      ; //µÈ´ý²â¾àÄ£¿é·µ»Ø¸ßµçÆ½ÐÅºÅ
 263   3                  TH2 = 0x00;
 264   3                  TL2 = 0x00;
 265   3                  distanceNum = 0; //Î¹¿´ÃÅ¹·
 266   3                  WDT_CONTR = 0x37;
 267   3              }
 268   2      
 269   2              if (distanceNew && distanceNewNum >= 2) //Èç¹û²â¾àµÄÊý¾Ý·¢ÉúÐÂµÄ±ä»¯
 270   2              {
 271   3                  uchar distanceCurRange = 0x00;
 272   3      
 273   3                  if (distanceLast >= 25 && distanceLast < 75) //¸ù¾ÝÐÂµÄ²â¾àÊý¾ÝÈ·¶¨Òª²¥·ÅµÄÓïÒôÎÄ¼þ
 274   3                  {
 275   4                      distanceCurRange = 0x01;
 276   4                  }
 277   3                  if (distanceLast >= 75 && distanceLast < 125)
 278   3                  {
 279   4                      distanceCurRange = 0x02;
 280   4                  }
 281   3                  if (distanceLast >= 125 && distanceLast < 175)
 282   3                  {
 283   4                      distanceCurRange = 0x03;
 284   4                  }
 285   3                  if (distanceLast >= 175 && distanceLast < 225)
 286   3                  {
 287   4                      distanceCurRange = 0x04;
 288   4                  }
 289   3                  if (distanceLast >= 225 && distanceLast < 275)
 290   3                  {
 291   4                      distanceCurRange = 0x05;
 292   4                  }
 293   3                  if (distanceLast >= 275 && distanceLast < 325)
 294   3                  {
 295   4                      distanceCurRange = 0x06;
 296   4                  }
 297   3                  if (distanceLast >= 325 && distanceLast < 375)
 298   3                  {
 299   4                      distanceCurRange = 0x07;
 300   4                  }
C51 COMPILER V9.59.0.0   PROGRAMER                                                         05/20/2020 16:51:00 PAGE 6   

 301   3                  if (distanceLast >= 375 && distanceLast < 425)
 302   3                  {
 303   4                      distanceCurRange = 0x08;
 304   4                  }
 305   3                  if (distanceLast >= 425 && distanceLast < 475)
 306   3                  {
 307   4                      distanceCurRange = 0x09;
 308   4                  }
 309   3                  if (distanceLast >= 475 && distanceLast < 525)
 310   3                  {
 311   4                      distanceCurRange = 0x0A;
 312   4                  }
 313   3                  if (distanceLast >= 525 && distanceLast < 575)
 314   3                  {
 315   4                      distanceCurRange = 0x0B;
 316   4                  }
 317   3      
 318   3                  if (distanceCurRange != 0x00 && distanceCurRange != distanceLastRange) //Èç¹ûÇ°·½ÓÐÕÏ°­Îï»òÒÑ¾
             -­»¹Ã»ÌáÊ¾¹ýÁË£¬Ôò·¢ËÍÏà¹ØÖ¸Áî
 319   3                  {
 320   4                      distanceLastRange = distanceCurRange;
 321   4                      mediaCommand[3] = 0x0F;
 322   4                      mediaCommand[5] = 0x01;
 323   4                      mediaCommand[6] = distanceCurRange;
 324   4                      sendData(mediaCommand, 8); //ÏòÓïÒôÄ£¿é·¢ËÍÖ¸Áî
 325   4                      delay(13500);
 326   4                      WDT_CONTR = 0x37; //Î¹¿´ÃÅ¹·
 327   4                  }
 328   3                  distanceNew = 0;
 329   3                  distanceNewNum = 0;
 330   3              }
 331   2      
 332   2              if (lightStatusNum >= 10) //Èç¹ûÍâ²¿»·¾³ÁÁ¶È·¢ÉúÁË±ä»¯£¬ÇÒ³ÖÐøÁËÒ»¶ÎÊ±¼ä
 333   2              {
 334   3                  lightStatus = P2_0;
 335   3                  P2_1 = !P2_0;
 336   3                  mediaCommand[3] = 0x0F;
 337   3                  mediaCommand[5] = 0x02;
 338   3                  mediaCommand[6] = lightStatus ? 0x01 : 0x02;
 339   3                  sendData(mediaCommand, 8); //ÏòÓïÒôÄ£¿é·¢ËÍÖ¸Áî
 340   3                  delay(13500);
 341   3                  WDT_CONTR = 0x37; //Î¹¿´ÃÅ¹·
 342   3                  lightStatusNum = 0;
 343   3              }
 344   2              switch (gsmIndex) //·Ö±ð¿ØÖÆÃ¿ÌõATÖ¸ÁîµÄ·¢ËÍ¼ä¸ôÊ±¼ä
 345   2              {
 346   3              case 0: //AT+CIPSHUT
 347   3                  if (gsmNum > 10)
 348   3                  {
 349   4                      sendAt();
 350   4                  }
 351   3                  break;
 352   3              case 1: //AT+CGATT?
 353   3                  if (gsmNum > 10)
 354   3                  {
 355   4                      sendAt();
 356   4                  }
 357   3                  break;
 358   3              case 2: //AT+CSTT="CMNET"
 359   3                  if (gsmNum > 10)
 360   3                  {
 361   4                      sendAt();
C51 COMPILER V9.59.0.0   PROGRAMER                                                         05/20/2020 16:51:00 PAGE 7   

 362   4                  }
 363   3                  break;
 364   3              case 3: //AT+CIICR
 365   3                  if (gsmNum > 50)
 366   3                  {
 367   4                      sendAt();
 368   4                  }
 369   3                  break;
 370   3              case 4: //AT+CIFSR
 371   3                  if (gsmNum > 50)
 372   3                  {
 373   4                      sendAt();
 374   4                  }
 375   3                  break;
 376   3              case 5: //AT+CIPSTART="TCP","120.78.203.170","12777"
 377   3                  if (gsmNum > 10)
 378   3                  {
 379   4                      sendAt();
 380   4                  }
 381   3                  break;
 382   3              case 6: //AT+CIPSEND
 383   3                  if (gsmNum > 150)
 384   3                  {
 385   4                      sendAt();
 386   4                  }
 387   3                  break;
 388   3              case 7: //gps¶¨Î»Êý¾Ý
 389   3                  if (gsmNum > 50)
 390   3                  {
 391   4                      sendAt();
 392   4                  }
 393   3                  break;
 394   3              case 8: //0x1A
 395   3                  if (gsmNum > 5)
 396   3                  {
 397   4                      sendAt();
 398   4                  }
 399   3                  break;
 400   3              case 9: //AT+CIPCLOSE
 401   3                  if (gsmNum > 10)
 402   3                  {
 403   4                      sendAt();
 404   4                  }
 405   3                  break;
 406   3              }
 407   2          }
 408   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1625    ----
   CONSTANT SIZE    =    147    ----
   XDATA SIZE       =    300      12
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
