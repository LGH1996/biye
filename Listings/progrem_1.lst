C51 COMPILER V9.59.0.0   PROGREM_1                                                         04/28/2020 23:17:21 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE PROGREM_1
OBJECT MODULE PLACED IN .\Objects\progrem_1.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE progrem_1.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Li
                    -stings\progrem_1.lst) TABS(2) OBJECT(.\Objects\progrem_1.obj)

line level    source

   1          #include<reg52.h>
   2          #include<intrins.h>
   3          #include<stdio.h>
   4          #include<string.h>
   5          
   6          #define uchar unsigned char
   7            
   8          sbit P1_1 = P1^1;
   9          sbit P1_2 = P1^2;
  10          sbit P2_0 = P2^0;
  11          sbit P2_1 = P2^1;
  12          bit ledStatus = 0;
  13          bit lastLedStatus = 0;
  14          bit newDistance = 0;
  15          uchar numWave = 0;
  16          uchar numLed = 0;
  17          uchar ledTip = 0;
  18          uchar distanceCount = 0;
  19          uchar lastRang = 0x00;
  20          int lastDistance = 0;
  21          
  22          
  23          
  24          void delay(unsigned int i){
  25   1        unsigned int n;
  26   1        for(n=0;n<i;n++){
  27   2        _nop_();
  28   2        }
  29   1      }
  30          
  31          void sendData(uchar str){
  32   1      
  33   1        SBUF = str;
  34   1        while(TI == 0);
  35   1        TI = 0;
  36   1        
  37   1      }
  38          
  39          void Time0() interrupt 1 using 0{
  40   1      
  41   1        if(++numLed >= 5){
  42   2          if(ledStatus != P2_0){
  43   3            if(++ledTip >= 4){
  44   4              ledStatus = P2_0;
  45   4              P2_1 = !P2_0;
  46   4            }
  47   3          } else if(ledTip < 4) {
  48   3            ledTip = 0;
  49   3          }
  50   2          if(ledStatus){
  51   3            P2_1 = !P2_1;
  52   3          }
  53   2          numLed = 0;
  54   2        }
C51 COMPILER V9.59.0.0   PROGREM_1                                                         04/28/2020 23:17:21 PAGE 2   

  55   1        
  56   1        numWave++;
  57   1        TH0 =0x4C;
  58   1        TL0= 0x00;
  59   1      }
  60          
  61          void Time2() interrupt 5 using 1{
  62   1      
  63   1        if(EXF2){
  64   2          int distance = ((RCAP2H<<8|RCAP2L)*1.085)/58;
  65   2          EXF2 = 0;
  66   2          if(distance < (lastDistance-50) || distance > (lastDistance+50)){
  67   3            lastDistance = distance;
  68   3            distanceCount = 0;
  69   3            newDistance = 1;
  70   3          } else {
  71   3            distanceCount++;
  72   3          }
  73   2        }
  74   1      }
  75          
  76          void main(){
  77   1      
  78   1        EA = 1; 
  79   1        
  80   1        ET0 = 1; //开T0定时器
  81   1        TR0 = 1;
  82   1        TMOD |= 0x01;
  83   1        TH0 =0x4C;
  84   1        TL0= 0x00;
  85   1        
  86   1        TR1 = 1;//开T1定时器，作为串口的波特率发生器
  87   1        TMOD |= 0x20;
  88   1        TL1 = 0xFD;
  89   1        TH1 = 0xFD;
  90   1        
  91   1        ET2 = 1;  //开T2捕获模式，测量超声波测距模块反馈的电压持续时间
  92   1        TR2 = 1;
  93   1        EXEN2 = 1;
  94   1        CP_RL2 = 1;
  95   1                 
  96   1        SM0 = 0; //串口初始化
  97   1        SM1 = 1;
  98   1        REN = 1;
  99   1        
 100   1        while(1){
 101   2          
 102   2          if(numWave >= 10){
 103   3            P1_2 = 0;
 104   3            delay(10);
 105   3            P1_2 = 1;
 106   3            while(P1_1 == 0);
 107   3            TH2 = 0x00;
 108   3            TL2 = 0x00;
 109   3            numWave = 0;
 110   3          }
 111   2          
 112   2          if(newDistance && distanceCount >= 2){
 113   3            
 114   3          uchar n, play[8] = {0x7E, 0xFF, 0x06, 0x0F, 0x00, 0x01, 0x00,0xEF},status[] = {0x7E, 0xFF, 0x06, 0x42, 0
             -x00, 0x00, 0x00, 0xEF},reply[10];
 115   3          uchar curRang = 0x00;
C51 COMPILER V9.59.0.0   PROGREM_1                                                         04/28/2020 23:17:21 PAGE 3   

 116   3          newDistance = 0;
 117   3          distanceCount = 0;
 118   3            
 119   3          for(n = 0;n<8;n++){
 120   4            sendData(status[n]);
 121   4          }
 122   3          
 123   3          for(n = 0;n<10;n++){
 124   4            unsigned int i = 0;
 125   4            bit a = 0;
 126   4            while(!RI){
 127   5              if(++i >= 1000){
 128   6                a = 1;
 129   6                break;
 130   6              }
 131   5            }
 132   4            reply[n] = a ? 0x01: SBUF;
 133   4            RI = 0;
 134   4          }
 135   3          
 136   3          if(reply[6] == 0x01){ 
 137   4            
 138   4            delay(1000);
 139   4            
 140   4          } else {
 141   4          
 142   4            if(lastDistance>=25 && lastDistance<75){
 143   5              curRang = 0x01;
 144   5            }
 145   4            if(lastDistance>=75 && lastDistance<125){
 146   5              curRang = 0x02;
 147   5            }
 148   4            if(lastDistance>=125 && lastDistance<175){
 149   5              curRang = 0x03;
 150   5            }
 151   4            if(lastDistance>=175 && lastDistance<225){
 152   5              curRang = 0x04;
 153   5            }
 154   4            if(lastDistance>=225 && lastDistance<275){
 155   5              curRang = 0x05;
 156   5            }
 157   4            if(lastDistance>=275 && lastDistance<325){
 158   5              curRang = 0x06;
 159   5            }
 160   4            if(lastDistance>=325 && lastDistance<375){
 161   5              curRang = 0x07;
 162   5            }
 163   4            if(lastDistance>=375 && lastDistance<425){
 164   5              curRang = 0x08;
 165   5            }
 166   4            if(lastDistance>=425 && lastDistance<475){
 167   5              curRang = 0x09;
 168   5            }
 169   4            if(lastDistance>=475 && lastDistance<525){
 170   5              curRang = 0x0A;
 171   5            }
 172   4            if(lastDistance>=525 && lastDistance<575){
 173   5              curRang = 0x0B;
 174   5            }
 175   4            
 176   4            if(curRang != 0x00 && curRang != lastRang){
 177   5              lastRang = curRang;
C51 COMPILER V9.59.0.0   PROGREM_1                                                         04/28/2020 23:17:21 PAGE 4   

 178   5              play[6] = curRang;
 179   5              for(n = 0;n<8;n++){
 180   6                sendData(play[n]);
 181   6              }
 182   5          }
 183   4        }
 184   3      } 
 185   2          
 186   2          if(ledTip >= 4){
 187   3            uchar n, play[8] = {0x7E, 0xFF, 0x06, 0x0F, 0x00, 0x02, 0x00,0xEF}, status[] = {0x7E, 0xFF, 0x06, 0x42,
             - 0x00, 0x00, 0x00, 0xEF},reply[10];
 188   3            for(n = 0;n<8;n++){
 189   4              sendData(status[n]);
 190   4            }
 191   3            for(n = 0;n<10;n++){
 192   4              unsigned int i = 0;
 193   4              bit a = 0;
 194   4              while(!RI){
 195   5                if(++i >= 1000){
 196   6                  a = 1;
 197   6                  break;
 198   6                }
 199   5              }
 200   4              reply[n] = a ? 0x01: SBUF;
 201   4              RI = 0;
 202   4            }
 203   3            if(reply[6] == 0x01){
 204   4              delay(1000);
 205   4            } else if(ledStatus != lastLedStatus){
 206   4            play[6] = ledStatus ? 0x01 : 0x02;
 207   4            for(n = 0;n<8;n++){
 208   5              sendData(play[n]);
 209   5            }
 210   4            lastLedStatus = ledStatus;
 211   4            ledTip = 0;
 212   4            }
 213   3          }
 214   2          
 215   2          } 
 216   1        }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1206    ----
   CONSTANT SIZE    =     32    ----
   XDATA SIZE       =      7      32
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
