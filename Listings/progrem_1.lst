C51 COMPILER V9.59.0.0   PROGREM_1                                                         05/11/2020 21:38:31 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE PROGREM_1
OBJECT MODULE PLACED IN .\Objects\progrem_1.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE progrem_1.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Li
                    -stings\progrem_1.lst) TABS(2) OBJECT(.\Objects\progrem_1.obj)

line level    source

   1          #include <reg52.h>
   2          #include <intrins.h>
   3          #include <string.h>
   4          
   5          #define IAP_ADDR 0x4000 //å†…éƒ¨REPPROMå­˜å‚¨è¯­éŸ³æ¨¡å—éŸ³é‡å€¼çš„åœ°å€
   6          #define uchar unsigned char
   7          #define uint unsigned int
   8          
   9          sfr WDT_CONTR = 0xE1; //å®šä¹‰çœ‹é—¨ç‹—æ§åˆ¶å¯„å­˜å™¨
  10          sfr IAP_DATA = 0xE2;  //å®šä¹‰æ“ä½œEPPROMç›¸å…³çš„ç‰¹æ®ŠåŠŸèƒ½å¯„å­˜å™¨
  11          sfr IAP_ADDRH = 0xE3;
  12          sfr IAP_ADDRL = 0xE4;
  13          sfr IAP_CMD = 0xE5;
  14          sfr IAP_TRIG = 0xE6;
  15          sfr IAP_CONTR = 0xE7;
  16          sbit Echo = P1 ^ 1; //å®šä¹‰å„ç±»å¼•è„š
  17          sbit Trig = P1 ^ 2;
  18          sbit P2_0 = P2 ^ 0;
  19          sbit P2_1 = P2 ^ 1;
  20          bit lightStatus = 0; //å®šä¹‰å„ç±»æ ‡å¿—ä½å’Œè¾…åŠ©å˜é‡
  21          bit distanceNew = 0;
  22          uchar distanceNum = 0;
  23          uchar lightNum = 0;
  24          uchar lightStatusNum = 0;
  25          uchar distanceNewNum = 0;
  26          uchar distanceLastRange = 0x00;
  27          int distanceLast = 0;
  28          uchar mediaCommand[] = {0x7E, 0xFF, 0x06, 0x00, 0x00, 0x00, 0x00, 0xEF}; //è¯­éŸ³æ’­æ”¾æ¨¡å—çš„æŒ‡ä»¤
  29          uchar volume = 0x0f;//è¯­éŸ³æ¨¡å—çš„å½“å‰å£°éŸ³å¤§å°
  30          uchar *gsmCmd[10] = {"AT+CIPSHUT\n", "AT+CGATT?\n", "AT+CSTT=\"CMNET\"\n",
  31                     "AT+CIICR\n", "AT+CIFSR\n", "AT+CIPSTART=\"TCP\",\"120.78.203.170\",\"12777\"\n",
  32                     "AT+CIPSEND\n", "gps", "\x1A", "AT+CIPCLOSE\n"}; //å¾ªç¯å‘é€çš„ATæŒ‡ä»¤
  33          uchar gsmNum = 0, gsmIndex = 0; //æ§åˆ¶ATæŒ‡ä»¤çš„å‘é€é¡ºåº
  34          uint receiveCount = 0;
  35          uchar receive[100], gpsSave[100]; //æ¥æ”¶å’Œä¿å­˜GPSå®šä½æ•°æ®
  36          
  37          void delay(uint i) //å»¶æ—¶å‡½æ•°
  38          {
  39   1        uint n;
  40   1        for (n = 0; n < i; n++)
  41   1        {
  42   2          _nop_();
  43   2        }
  44   1      }
  45          
  46          void sendData(uchar str[], uchar lenth) //å‘ä¸²è¡Œå£å‘é€æ•°æ®
  47          {
  48   1        uint n;
  49   1        for (n = 0; n < lenth; n++)
  50   1        {
  51   2          SBUF = str[n];
  52   2          while (TI == 0)
  53   2            ;
  54   2          TI = 0;
C51 COMPILER V9.59.0.0   PROGREM_1                                                         05/11/2020 21:38:31 PAGE 2   

  55   2        }
  56   1      }
  57          
  58          void sendAt() //å‘é€ATæŒ‡ä»¤
  59          {
  60   1        sendData(gsmCmd[gsmIndex], strlen(gsmCmd[gsmIndex]));
  61   1        gsmNum = 0;
  62   1        gsmIndex++;
  63   1        gsmIndex %= 10;
  64   1        delay(1000);
  65   1      }
  66          
  67          void IapIdle() //è¿›å…¥å¾…æœºæ¨¡å¼ï¼Œæ— ISP/IAPæ“ä½œ
  68          {
  69   1        IAP_CONTR = 0;
  70   1        IAP_CMD = 0;
  71   1        IAP_TRIG = 0;
  72   1        IAP_ADDRH = 0x80;
  73   1        IAP_ADDRL = 0;
  74   1      }
  75          
  76          uchar IapReadByte(uint addr) //å¯¹å†…éƒ¨RPPROMè¿›è¡Œè¯»å–æ•°æ®æ“ä½œ
  77          {
  78   1        uchar dat;
  79   1        IAP_CONTR = 0x81;
  80   1        IAP_CMD = 0x01;
  81   1        IAP_ADDRL = addr;
  82   1        IAP_ADDRH = addr >> 8;
  83   1        IAP_TRIG = 0x46;
  84   1        IAP_TRIG = 0xb9;
  85   1        _nop_();
  86   1        dat = IAP_DATA;
  87   1        IapIdle();
  88   1        return dat;
  89   1      }
  90          
  91          void IapProgramByte(uint addr, uchar dat) //å¯¹å†…éƒ¨REPPROMè¿›è¡Œå†™å…¥æ•°æ®æ“ä½œ
  92          {
  93   1        IAP_CONTR = 0x81;
  94   1        IAP_CMD = 0x02;
  95   1        IAP_ADDRL = addr;
  96   1        IAP_ADDRH = addr >> 8;
  97   1        IAP_DATA = dat;
  98   1        IAP_TRIG = 0x46;
  99   1        IAP_TRIG = 0xb9;
 100   1        _nop_();
 101   1        IapIdle();
 102   1      }
 103          
 104          void IapEraseSector(uint addr) //æ“¦é™¤å†…éƒ¨EPPROMçš„æŒ‡å®šæ‰‡åŒº
 105          {
 106   1        IAP_CONTR = 0x81;
 107   1        IAP_CMD = 0x03;
 108   1        IAP_ADDRL = addr;
 109   1        IAP_ADDRH = addr >> 8;
 110   1        IAP_TRIG = 0x46;
 111   1        IAP_TRIG = 0xb9;
 112   1        _nop_();
 113   1        IapIdle();
 114   1      }
 115          
 116          void Time0() interrupt 1 using 0 //å®šæ—¶å™¨T0ä¸­æ–­å‡½æ•°
C51 COMPILER V9.59.0.0   PROGREM_1                                                         05/11/2020 21:38:31 PAGE 3   

 117          {
 118   1      
 119   1        if (++lightNum >= 5) //æ£€æŸ¥å¤–éƒ¨å…‰çº¿å¼ºåº¦çš„å˜åŒ–
 120   1        {
 121   2          if (P2_0 != lightStatus)
 122   2          {
 123   3            lightStatusNum++;
 124   3          }
 125   2          else
 126   2          {
 127   3            lightStatusNum = 0;
 128   3          }
 129   2          if (lightStatus)
 130   2          {
 131   3            P2_1 = !P2_1; //æŒ‡ç¤ºç¯é—ªçƒ
 132   3          }
 133   2          lightNum = 0;
 134   2        }
 135   1      
 136   1        gsmNum++;
 137   1        distanceNum++;
 138   1        TH0 = 0x4C; //é‡æ–°è£…è½½åˆå€¼
 139   1        TL0 = 0x00;
 140   1      }
 141          
 142          void Time2() interrupt 5 using 1 //å®šæ—¶å™¨T2çš„ä¸­æ–­å‡½æ•°
 143          {
 144   1      
 145   1        if (EXF2) //ä½¿ç”¨å®šæ—¶å™¨T2çš„æ•è·æ¨¡å¼
 146   1        {
 147   2          double rcap = (RCAP2H << 8 | RCAP2L);       //è·å–å‘ç”Ÿä¸­æ–­æ—¶çš„TH2å’ŒTL2çš„å€¼
 148   2          int distance = (rcap * (12 / 11.0592) * 0.034) / 2; //è®¡ç®—å‡ºä¸éšœç¢ç‰©çš„è·ç¦»
 149   2          EXF2 = 0;
 150   2          if (distance < (distanceLast - 50) || distance > (distanceLast + 50)) //åˆ¤æ–­ä¸éšœç¢çš„è·ç¦»æ˜¯å¦å
             -‘ç”Ÿäº†è¾ƒå¤§çš„å˜åŒ–
 151   2          {
 152   3            distanceLast = distance;
 153   3            distanceNewNum = 0;
 154   3            distanceNew = 1;
 155   3          }
 156   2          else
 157   2          {
 158   3            distanceNewNum++;
 159   3          }
 160   2        }
 161   1      }
 162          
 163          void serial_4() interrupt 4 using 3 //UARTä¸­æ–­ï¼Œä¸»è¦ç”¨æ¥æ¥æ”¶GPSæ¨¡å—çš„å®šä½æ•°æ®
 164          {
 165   1        if (RI)
 166   1        {
 167   2          uchar temp = SBUF;
 168   2          RI = 0;
 169   2          receive[receiveCount++] = temp;
 170   2          if (temp == '\n')
 171   2          {
 172   3            receive[receiveCount] = 0;
 173   3            if (receive[0] == '$' && receive[3] == 'G' && receive[4] == 'G' && receive[5] == 'A' && receiveCount >=
             - 50 && receiveCount < 100)
 174   3            {
 175   4              strcpy(gpsSave, receive);
 176   4            }
C51 COMPILER V9.59.0.0   PROGREM_1                                                         05/11/2020 21:38:31 PAGE 4   

 177   3            receiveCount = 0;
 178   3            receive[0] = 0;
 179   3          }
 180   2        }
 181   1      }
 182          
 183          void external_0() interrupt 0 using 2 //å¤–éƒ¨ä¸­æ–­INT0çš„ä¸­æ–­å‡½æ•°ï¼Œè¯­éŸ³æ¨¡å—éŸ³é‡åŠ 1
 184          {
 185   1        if (volume < 30)
 186   1        {
 187   2          mediaCommand[3] = 0x06;
 188   2          mediaCommand[6] = ++volume;
 189   2          sendData(mediaCommand, 8);
 190   2          IapEraseSector(IAP_ADDR);
 191   2          IapProgramByte(IAP_ADDR, volume);
 192   2        }
 193   1      }
 194          
 195          void external_1() interrupt 2 using 2 //å¤–éƒ¨ä¸­æ–­INT1çš„ä¸­æ–­å‡½æ•°ï¼Œè¯­éŸ³æ¨¡å—éŸ³é‡å‡1
 196          {
 197   1        if (volume > 5)
 198   1        {
 199   2          mediaCommand[3] = 0x06;
 200   2          mediaCommand[6] = --volume;
 201   2          sendData(mediaCommand, 8);
 202   2          IapEraseSector(IAP_ADDR);
 203   2          IapProgramByte(IAP_ADDR, volume);
 204   2        }
 205   1      }
 206          
 207          void main()
 208          {
 209   1      
 210   1        EA = 1; //å¼€æ€»ä¸­æ–­
 211   1      
 212   1        ET0 = 1; //å¼€T0ä¸­æ–­
 213   1        TR0 = 1;
 214   1        TMOD |= 0x01;
 215   1        TH0 = 0x4C;
 216   1        TL0 = 0x00;
 217   1      
 218   1        TR1 = 1; //è®¾ç½®å®šæ—¶å™¨T1ä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨
 219   1        TMOD |= 0x20;
 220   1        TL1 = 0xFD;
 221   1        TH1 = 0xFD;
 222   1      
 223   1        ET2 = 1; //å¼€å®šæ—¶å™¨/è®¡æ•°å™¨T2çš„æ•è·æ¨¡å¼
 224   1        TR2 = 1;
 225   1        EXEN2 = 1;
 226   1        CP_RL2 = 1;
 227   1      
 228   1        ES = 1; //å¼€UARTä¸­æ–­ï¼Œè®¾ç½®ä¸²è¡Œå£é€šè®¯çš„å·¥ä½œæ¨¡å¼
 229   1        SM0 = 0;
 230   1        SM1 = 1;
 231   1        REN = 1;
 232   1      
 233   1        EX0 = 1; //å¼€å¤–éƒ¨ä¸­æ–­INT0å’ŒINT1
 234   1        EX1 = 1;
 235   1        IT0 = 1;
 236   1        IT1 = 1;
 237   1      
 238   1        WDT_CONTR = 0x37; //å¼€çœ‹é—¨ç‹—ï¼Œåœ¨å—åˆ°å¹²æ‰°ä½¿ç¨‹åºè·‘é£æ—¶è‡ªåŠ¨å¤ä½
C51 COMPILER V9.59.0.0   PROGREM_1                                                         05/11/2020 21:38:31 PAGE 5   

 239   1      
 240   1        memset(receive, 0, 100);
 241   1        memset(gpsSave, 0, 100);
 242   1        gsmCmd[7] = gpsSave;
 243   1      
 244   1        delay(20000); //ç­‰å¾…è¯­éŸ³æ¨¡å—å¯åŠ¨å®Œæ¯•å
 245   1        volume = IapReadByte(IAP_ADDR);
 246   1        mediaCommand[3] = 0x06;
 247   1        mediaCommand[6] = volume;
 248   1        sendData(mediaCommand, 8); //åˆå§‹åŒ–è¯­éŸ³æ¨¡å—çš„éŸ³é‡å¤§å°
 249   1      
 250   1        while (1)
 251   1        {
 252   2      
 253   2          if (distanceNum >= 10) //åœ¨é—´éš”ä¸€å®šçš„æ—¶é—´åå‘æµ‹è·æ¨¡å—å‘é€é«˜ç”µå¹³è„‰å†²
 254   2          {
 255   3            Trig = 0;
 256   3            delay(10);
 257   3            Trig = 1;
 258   3            while (!Echo)
 259   3              ; //ç­‰å¾…æµ‹è·æ¨¡å—è¿”å›é«˜ç”µå¹³ä¿¡å·
 260   3            TH2 = 0x00;
 261   3            TL2 = 0x00;
 262   3            distanceNum = 0; //å–‚çœ‹é—¨ç‹—
 263   3            WDT_CONTR = 0x37;
 264   3          }
 265   2      
 266   2          if (distanceNew && distanceNewNum >= 2) //å¦‚æœæµ‹è·çš„æ•°æ®å‘ç”Ÿæ–°çš„å˜åŒ–
 267   2          {
 268   3            uchar distanceCurRange = 0x00;
 269   3      
 270   3            if (distanceLast >= 25 && distanceLast < 75) //æ ¹æ®æ–°çš„æµ‹è·æ•°æ®ç¡®å®šè¦æ’­æ”¾çš„è¯­éŸ³æ–‡ä»¶
 271   3            {
 272   4              distanceCurRange = 0x01;
 273   4            }
 274   3            if (distanceLast >= 75 && distanceLast < 125)
 275   3            {
 276   4              distanceCurRange = 0x02;
 277   4            }
 278   3            if (distanceLast >= 125 && distanceLast < 175)
 279   3            {
 280   4              distanceCurRange = 0x03;
 281   4            }
 282   3            if (distanceLast >= 175 && distanceLast < 225)
 283   3            {
 284   4              distanceCurRange = 0x04;
 285   4            }
 286   3            if (distanceLast >= 225 && distanceLast < 275)
 287   3            {
 288   4              distanceCurRange = 0x05;
 289   4            }
 290   3            if (distanceLast >= 275 && distanceLast < 325)
 291   3            {
 292   4              distanceCurRange = 0x06;
 293   4            }
 294   3            if (distanceLast >= 325 && distanceLast < 375)
 295   3            {
 296   4              distanceCurRange = 0x07;
 297   4            }
 298   3            if (distanceLast >= 375 && distanceLast < 425)
 299   3            {
 300   4              distanceCurRange = 0x08;
C51 COMPILER V9.59.0.0   PROGREM_1                                                         05/11/2020 21:38:31 PAGE 6   

 301   4            }
 302   3            if (distanceLast >= 425 && distanceLast < 475)
 303   3            {
 304   4              distanceCurRange = 0x09;
 305   4            }
 306   3            if (distanceLast >= 475 && distanceLast < 525)
 307   3            {
 308   4              distanceCurRange = 0x0A;
 309   4            }
 310   3            if (distanceLast >= 525 && distanceLast < 575)
 311   3            {
 312   4              distanceCurRange = 0x0B;
 313   4            }
 314   3      
 315   3            if (distanceCurRange != 0x00 && distanceCurRange != distanceLastRange) //å¦‚æœå‰æ–¹æœ‰éšœç¢ç‰©æˆ–å·²
             -ç»è¿˜æ²¡æç¤ºè¿‡äº†ï¼Œåˆ™å‘é€ç›¸å…³æŒ‡ä»¤
 316   3            {
 317   4              distanceLastRange = distanceCurRange;
 318   4              mediaCommand[3] = 0x0F;
 319   4              mediaCommand[5] = 0x01;
 320   4              mediaCommand[6] = distanceCurRange;
 321   4              sendData(mediaCommand, 8); //å‘è¯­éŸ³æ¨¡å—å‘é€æŒ‡ä»¤
 322   4              delay(13500);
 323   4              WDT_CONTR = 0x37; //å–‚çœ‹é—¨ç‹—
 324   4            }
 325   3            distanceNew = 0;
 326   3            distanceNewNum = 0;
 327   3          }
 328   2      
 329   2          if (lightStatusNum >= 10) //å¦‚æœå¤–éƒ¨ç¯å¢ƒäº®åº¦å‘ç”Ÿäº†å˜åŒ–ï¼Œä¸”æŒç»­äº†ä¸€æ®µæ—¶é—´
 330   2          {
 331   3            lightStatus = P2_0;
 332   3            P2_1 = !P2_0;
 333   3            mediaCommand[3] = 0x0F;
 334   3            mediaCommand[5] = 0x02;
 335   3            mediaCommand[6] = lightStatus ? 0x01 : 0x02;
 336   3            sendData(mediaCommand, 8); //å‘è¯­éŸ³æ¨¡å—å‘é€æŒ‡ä»¤
 337   3            delay(13500);
 338   3            WDT_CONTR = 0x37; //å–‚çœ‹é—¨ç‹—
 339   3            lightStatusNum = 0;
 340   3          }
 341   2          switch (gsmIndex) //åˆ†åˆ«æ§åˆ¶æ¯æ¡ATæŒ‡ä»¤çš„å‘é€é—´éš”æ—¶é—´
 342   2          {
 343   3          case 0: //AT+CIPSHUT
 344   3            if (gsmNum > 10)
 345   3            {
 346   4              sendAt();
 347   4            }
 348   3            break;
 349   3          case 1: //AT+CGATT?
 350   3            if (gsmNum > 10)
 351   3            {
 352   4              sendAt();
 353   4            }
 354   3            break;
 355   3          case 2: //AT+CSTT="CMNET"
 356   3            if (gsmNum > 10)
 357   3            {
 358   4              sendAt();
 359   4            }
 360   3            break;
 361   3          case 3: //AT+CIICR
C51 COMPILER V9.59.0.0   PROGREM_1                                                         05/11/2020 21:38:31 PAGE 7   

 362   3            if (gsmNum > 50)
 363   3            {
 364   4              sendAt();
 365   4            }
 366   3            break;
 367   3          case 4: //AT+CIFSR
 368   3            if (gsmNum > 50)
 369   3            {
 370   4              sendAt();
 371   4            }
 372   3            break;
 373   3          case 5: //AT+CIPSTART="TCP","120.78.203.170","12777"
 374   3            if (gsmNum > 10)
 375   3            {
 376   4              sendAt();
 377   4            }
 378   3            break;
 379   3          case 6: //AT+CIPSEND
 380   3            if (gsmNum > 150)
 381   3            {
 382   4              sendAt();
 383   4            }
 384   3            break;
 385   3          case 7: //gpså®šä½æ•°æ®
 386   3            if (gsmNum > 50)
 387   3            {
 388   4              sendAt();
 389   4            }
 390   3            break;
 391   3          case 8: //0x1A
 392   3            if (gsmNum > 5)
 393   3            {
 394   4              sendAt();
 395   4            }
 396   3            break;
 397   3          case 9: //AT+CIPCLOSE
 398   3            if (gsmNum > 10)
 399   3            {
 400   4              sendAt();
 401   4            }
 402   3            break;
 403   3          }
 404   2        }
 405   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1656    ----
   CONSTANT SIZE    =    135    ----
   XDATA SIZE       =    250      12
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
