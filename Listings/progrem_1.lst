C51 COMPILER V9.59.0.0   PROGREM_1                                                         05/06/2020 17:54:46 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE PROGREM_1
OBJECT MODULE PLACED IN .\Objects\progrem_1.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE progrem_1.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Li
                    -stings\progrem_1.lst) TABS(2) OBJECT(.\Objects\progrem_1.obj)

line level    source

   1          #include <reg52.h>
   2          #include <intrins.h>
   3          
   4          #define IAP_ADDR 0x4000 //å†…éƒ¨REPPROMå­˜å‚¨è¯­éŸ³æ¨¡å—éŸ³é‡å€¼çš„åœ°å€
   5          #define uchar unsigned char
   6          #define uint unsigned int
   7          
   8          sfr WDT_CONTR = 0xE1; //å®šä¹‰çœ‹é—¨ç‹—æ§åˆ¶å¯„å­˜å™¨
   9          sfr IAP_DATA = 0xE2;  //å®šä¹‰æ“ä½œEPPROMç›¸å…³çš„ç‰¹æ®ŠåŠŸèƒ½å¯„å­˜å™¨
  10          sfr IAP_ADDRH = 0xE3;
  11          sfr IAP_ADDRL = 0xE4;
  12          sfr IAP_CMD = 0xE5;
  13          sfr IAP_TRIG = 0xE6;
  14          sfr IAP_CONTR = 0xE7;
  15          sbit Echo = P1 ^ 1; //å®šä¹‰å„ç±»å¼•è„š
  16          sbit Trig = P1 ^ 2;
  17          sbit P2_0 = P2 ^ 0;
  18          sbit P2_1 = P2 ^ 1;
  19          bit lightStatus = 0; //å®šä¹‰å„ç±»æ ‡å¿—ä½å’Œè¾…åŠ©å˜é‡
  20          bit distanceNew = 0;
  21          uchar distanceNum = 0;
  22          uchar lightNum = 0;
  23          uchar lightStatusNum = 0;
  24          uchar distanceNewNum = 0;
  25          uchar distanceLastRange = 0x00;
  26          int distanceLast = 0;
  27          uchar mediaCommand[] = {0x7E, 0xFF, 0x06, 0x00, 0x00, 0x00, 0x00, 0xEF}; //è¯­éŸ³æ’­æ”¾æ¨¡å—çš„æŒ‡ä»¤
  28          uchar volume = 0x0f;                           //è¯­éŸ³æ¨¡å—çš„å½“å‰å£°éŸ³å¤§å°
  29          
  30          void delay(uint i) //å»¶æ—¶å‡½æ•°
  31          {
  32   1        uint n;
  33   1        for (n = 0; n < i; n++)
  34   1        {
  35   2          _nop_();
  36   2        }
  37   1      }
  38          
  39          void sendData(uchar str[], uchar lenth) //å‘ä¸²è¡Œå£å‘é€æ•°æ®
  40          {
  41   1        uint n;
  42   1        for (n = 0; n < lenth; n++)
  43   1        {
  44   2          SBUF = str[n];
  45   2          while (TI == 0)
  46   2            ;
  47   2          TI = 0;
  48   2        }
  49   1      }
  50          
  51          void IapIdle() //è¿›å…¥å¾…æœºæ¨¡å¼ï¼Œæ— ISP/IAPæ“ä½œ
  52          {
  53   1        IAP_CONTR = 0;
  54   1        IAP_CMD = 0;
C51 COMPILER V9.59.0.0   PROGREM_1                                                         05/06/2020 17:54:46 PAGE 2   

  55   1        IAP_TRIG = 0;
  56   1        IAP_ADDRH = 0x80;
  57   1        IAP_ADDRL = 0;
  58   1      }
  59          
  60          uchar IapReadByte(uint addr) //å¯¹å†…éƒ¨RPPROMè¿›è¡Œè¯»å–æ•°æ®æ“ä½œ
  61          {
  62   1        uchar dat;
  63   1        IAP_CONTR = 0x81;
  64   1        IAP_CMD = 0x01;
  65   1        IAP_ADDRL = addr;
  66   1        IAP_ADDRH = addr >> 8;
  67   1        IAP_TRIG = 0x46;
  68   1        IAP_TRIG = 0xb9;
  69   1        _nop_();
  70   1        dat = IAP_DATA;
  71   1        IapIdle();
  72   1        return dat;
  73   1      }
  74          
  75          void IapProgramByte(uint addr, uchar dat) //å¯¹å†…éƒ¨REPPROMè¿›è¡Œå†™å…¥æ•°æ®æ“ä½œ
  76          {
  77   1        IAP_CONTR = 0x81;
  78   1        IAP_CMD = 0x02;
  79   1        IAP_ADDRL = addr;
  80   1        IAP_ADDRH = addr >> 8;
  81   1        IAP_DATA = dat;
  82   1        IAP_TRIG = 0x46;
  83   1        IAP_TRIG = 0xb9;
  84   1        _nop_();
  85   1        IapIdle();
  86   1      }
  87          
  88          void IapEraseSector(uint addr) //æ“¦é™¤å†…éƒ¨EPPROMçš„æŒ‡å®šæ‰‡åŒº
  89          {
  90   1        IAP_CONTR = 0x81;
  91   1        IAP_CMD = 0x03;
  92   1        IAP_ADDRL = addr;
  93   1        IAP_ADDRH = addr >> 8;
  94   1        IAP_TRIG = 0x46;
  95   1        IAP_TRIG = 0xb9;
  96   1        _nop_();
  97   1        IapIdle();
  98   1      }
  99          
 100          void Time0() interrupt 1 using 0 //å®šæ—¶å™¨T0ä¸­æ–­å‡½æ•°
 101          {
 102   1      
 103   1        if (++lightNum >= 5) //æ£€æŸ¥å¤–éƒ¨å…‰çº¿å¼ºåº¦çš„å˜åŒ–
 104   1        {
 105   2          if (P2_0 != lightStatus)
 106   2          {
 107   3            lightStatusNum++;
 108   3          }
 109   2          else
 110   2          {
 111   3            lightStatusNum = 0;
 112   3          }
 113   2          if (lightStatus)
 114   2          {
 115   3            P2_1 = !P2_1; //æŒ‡ç¤ºç¯é—ªçƒ
 116   3          }
C51 COMPILER V9.59.0.0   PROGREM_1                                                         05/06/2020 17:54:46 PAGE 3   

 117   2          lightNum = 0;
 118   2          WDT_CONTR = 0x37; //é—®çœ‹é—¨ç‹—
 119   2        }
 120   1        distanceNum++;
 121   1        TH0 = 0x4C; //é‡æ–°è£…è½½åˆå€¼
 122   1        TL0 = 0x00;
 123   1      }
 124          
 125          void Time2() interrupt 5 using 1 //å®šæ—¶å™¨T2çš„ä¸­æ–­å‡½æ•°
 126          {
 127   1      
 128   1        if (EXF2) //ä½¿ç”¨å®šæ—¶å™¨T2çš„æ•è·æ¨¡å¼
 129   1        {
 130   2          double rcap = (RCAP2H << 8 | RCAP2L);       //è·å–å‘ç”Ÿä¸­æ–­æ—¶çš„TH2å’ŒTL2çš„å€¼
 131   2          int distance = (rcap * (12 / 11.0592) * 0.034) / 2; //è®¡ç®—å‡ºä¸éšœç¢ç‰©çš„è·ç¦»
 132   2          EXF2 = 0;
 133   2          if (distance < (distanceLast - 50) || distance > (distanceLast + 50)) //åˆ¤æ–­ä¸éšœç¢çš„è·ç¦»æ˜¯å¦å
             -‘ç”Ÿäº†è¾ƒå¤§çš„å˜åŒ–
 134   2          {
 135   3            distanceLast = distance;
 136   3            distanceNewNum = 0;
 137   3            distanceNew = 1;
 138   3          }
 139   2          else
 140   2          {
 141   3            distanceNewNum++;
 142   3          }
 143   2        }
 144   1      }
 145          
 146          void external_0() interrupt 0 using 2 //å¤–éƒ¨ä¸­æ–­INT0çš„ä¸­æ–­å‡½æ•°ï¼Œè¯­éŸ³æ¨¡å—éŸ³é‡åŠ 1
 147          {
 148   1        if (volume < 30)
 149   1        {
 150   2          mediaCommand[3] = 0x06;
 151   2          mediaCommand[6] = ++volume;
 152   2          sendData(mediaCommand, 8);
 153   2          IapEraseSector(IAP_ADDR);
 154   2          IapProgramByte(IAP_ADDR, volume);
 155   2        }
 156   1      }
 157          
 158          void external_1() interrupt 2 using 2 //å¤–éƒ¨ä¸­æ–­INT1çš„ä¸­æ–­å‡½æ•°ï¼Œè¯­éŸ³æ¨¡å—éŸ³é‡å‡1
 159          {
 160   1        if (volume > 5)
 161   1        {
 162   2          mediaCommand[3] = 0x06;
 163   2          mediaCommand[6] = --volume;
 164   2          sendData(mediaCommand, 8);
 165   2          IapEraseSector(IAP_ADDR);
 166   2          IapProgramByte(IAP_ADDR, volume);
 167   2        }
 168   1      }
 169          
 170          void main()
 171          {
 172   1      
 173   1        EA = 1; //å¼€æ€»ä¸­æ–­
 174   1      
 175   1        ET0 = 1; //å¼€T0ä¸­æ–­
 176   1        TR0 = 1;
 177   1        TMOD |= 0x01;
C51 COMPILER V9.59.0.0   PROGREM_1                                                         05/06/2020 17:54:46 PAGE 4   

 178   1        TH0 = 0x4C;
 179   1        TL0 = 0x00;
 180   1      
 181   1        TR1 = 1; //è®¾ç½®å®šæ—¶å™¨T1ä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨
 182   1        TMOD |= 0x20;
 183   1        TL1 = 0xFD;
 184   1        TH1 = 0xFD;
 185   1      
 186   1        ET2 = 1; //å¼€å®šæ—¶å™¨/è®¡æ•°å™¨T2çš„æ•è·æ¨¡å¼
 187   1        TR2 = 1;
 188   1        EXEN2 = 1;
 189   1        CP_RL2 = 1;
 190   1      
 191   1        SM0 = 0; //è®¾ç½®ä¸²è¡Œå£é€šè®¯çš„å·¥ä½œæ¨¡å¼
 192   1        SM1 = 1;
 193   1        REN = 1;
 194   1      
 195   1        EX0 = 1; //å¼€å¤–éƒ¨ä¸­æ–­INT0å’ŒINT1
 196   1        EX1 = 1;
 197   1        IT0 = 1;
 198   1        IT1 = 1;
 199   1      
 200   1        WDT_CONTR = 0x37; //å¼€çœ‹é—¨ç‹—ï¼Œåœ¨å—åˆ°å¹²æ‰°ä½¿ç¨‹åºè·‘é£æ—¶è‡ªåŠ¨å¤ä½
 201   1      
 202   1        delay(10000); //ç­‰å¾…è¯­éŸ³æ¨¡å—å¯åŠ¨å®Œæ¯•å
 203   1        volume = IapReadByte(IAP_ADDR);
 204   1        mediaCommand[3] = 0x06;
 205   1        mediaCommand[6] = volume;
 206   1        sendData(mediaCommand, 8); //åˆå§‹åŒ–è¯­éŸ³æ¨¡å—çš„éŸ³é‡å¤§å°
 207   1      
 208   1        while (1)
 209   1        {
 210   2      
 211   2          if (distanceNum >= 10) //åœ¨é—´éš”ä¸€å®šçš„æ—¶é—´åå‘æµ‹è·æ¨¡å—å‘é€é«˜ç”µå¹³è„‰å†²
 212   2          {
 213   3            Trig = 0;
 214   3            delay(10);
 215   3            Trig = 1;
 216   3            while (!Echo)
 217   3              ; //ç­‰å¾…æµ‹è·æ¨¡å—è¿”å›é«˜ç”µå¹³ä¿¡å·
 218   3            TH2 = 0x00;
 219   3            TL2 = 0x00;
 220   3            distanceNum = 0; //å–‚çœ‹é—¨ç‹—
 221   3            WDT_CONTR = 0x37;
 222   3          }
 223   2      
 224   2          if (distanceNew && distanceNewNum >= 2) //å¦‚æœæµ‹è·çš„æ•°æ®å‘ç”Ÿæ–°çš„å˜åŒ–
 225   2          {
 226   3            uchar distanceCurRange = 0x00;
 227   3      
 228   3            if (distanceLast >= 25 && distanceLast < 75) //æ ¹æ®æ–°çš„æµ‹è·æ•°æ®ç¡®å®šè¦æ’­æ”¾çš„è¯­éŸ³æ–‡ä»¶
 229   3            {
 230   4              distanceCurRange = 0x01;
 231   4            }
 232   3            if (distanceLast >= 75 && distanceLast < 125)
 233   3            {
 234   4              distanceCurRange = 0x02;
 235   4            }
 236   3            if (distanceLast >= 125 && distanceLast < 175)
 237   3            {
 238   4              distanceCurRange = 0x03;
 239   4            }
C51 COMPILER V9.59.0.0   PROGREM_1                                                         05/06/2020 17:54:46 PAGE 5   

 240   3            if (distanceLast >= 175 && distanceLast < 225)
 241   3            {
 242   4              distanceCurRange = 0x04;
 243   4            }
 244   3            if (distanceLast >= 225 && distanceLast < 275)
 245   3            {
 246   4              distanceCurRange = 0x05;
 247   4            }
 248   3            if (distanceLast >= 275 && distanceLast < 325)
 249   3            {
 250   4              distanceCurRange = 0x06;
 251   4            }
 252   3            if (distanceLast >= 325 && distanceLast < 375)
 253   3            {
 254   4              distanceCurRange = 0x07;
 255   4            }
 256   3            if (distanceLast >= 375 && distanceLast < 425)
 257   3            {
 258   4              distanceCurRange = 0x08;
 259   4            }
 260   3            if (distanceLast >= 425 && distanceLast < 475)
 261   3            {
 262   4              distanceCurRange = 0x09;
 263   4            }
 264   3            if (distanceLast >= 475 && distanceLast < 525)
 265   3            {
 266   4              distanceCurRange = 0x0A;
 267   4            }
 268   3            if (distanceLast >= 525 && distanceLast < 575)
 269   3            {
 270   4              distanceCurRange = 0x0B;
 271   4            }
 272   3      
 273   3            if (distanceCurRange != 0x00 && distanceCurRange != distanceLastRange) //å¦‚æœå‰æ–¹æœ‰éšœç¢ç‰©æˆ–å·²
             -ç»è¿˜æ²¡æç¤ºè¿‡äº†ï¼Œåˆ™å‘é€ç›¸å…³æŒ‡ä»¤
 274   3            {
 275   4              distanceLastRange = distanceCurRange;
 276   4              mediaCommand[3] = 0x0F;
 277   4              mediaCommand[5] = 0x01;
 278   4              mediaCommand[6] = distanceCurRange;
 279   4              sendData(mediaCommand, 8); //å‘è¯­éŸ³æ¨¡å—å‘é€æŒ‡ä»¤
 280   4              delay(13500);
 281   4              WDT_CONTR = 0x37; //å–‚çœ‹é—¨ç‹—
 282   4            }
 283   3            distanceNew = 0;
 284   3            distanceNewNum = 0;
 285   3          }
 286   2      
 287   2          if (lightStatusNum >= 10) //å¦‚æœå¤–éƒ¨ç¯å¢ƒäº®åº¦å‘ç”Ÿäº†å˜åŒ–ï¼Œå´æŒç»­äº†ä¸€æ®µæ—¶é—´
 288   2          {
 289   3            lightStatus = P2_0;
 290   3            P2_1 = !P2_0;
 291   3            mediaCommand[3] = 0x0F;
 292   3            mediaCommand[5] = 0x02;
 293   3            mediaCommand[6] = lightStatus ? 0x01 : 0x02;
 294   3            sendData(mediaCommand, 8); //å‘è¯­éŸ³æ¨¡å—å‘é€æŒ‡ä»¤
 295   3            delay(13500);
 296   3            WDT_CONTR = 0x37; //å–‚çœ‹é—¨ç‹—
 297   3            lightStatusNum = 0;
 298   3          }
 299   2        }
 300   1      }
C51 COMPILER V9.59.0.0   PROGREM_1                                                         05/06/2020 17:54:46 PAGE 6   



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1121    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     16      11
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
